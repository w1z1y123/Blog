---

desc: "并发与同步"
tags: "操作系统"
outline: deep
---

# 互斥与并发

## 并发的原理

## 🚂读者/写者问题

### 条件
- `同时读`：允许多个读者进程可以同时读数据
- `互斥写`：不允许多个写者进行同时写数据
- `互斥读写`：如果有写者正在写数据，不允许读者进程读数据
  
### 解决策略
- 读者优先
- 写者优先
- 公平优先




**读者优先**
::: tip 规则
- 一旦有读者正在读数据，允许随后的读者进入读数据
- 只有当全部读者退出，才允许写者进入写数据
- 容易导致<WarnBlock>写者饥饿</warnBlock>

:::
``` c {1-3,12,17}
 wsem :互斥信号量,用于Writers和Readers 互斥
 readcount :统计同时读数据的Readers 个数
 mutex :对变量readcount 互斥算术操作
// 信号量定义
semaphore wsem=1;
semaphore mutes=1;
int readcount=0;
reader: 
   while(true){
        p(mutex);
        readcount++;
        if(readcount==1) p(wsem); //🔒.只有第一个读者，
        v(mutex);
        读数据
        p(mutex);
        readcount--;
        if(readcount==0) v(wsem); //🔓.直到最后一个读者
        v(mutex);
    }
writer：
    while(true){
        p(wsem);
        写数据
        v(wsem);
    }
```
**公平优先**
::: tip 规则
- 读、写过程中，若其他读者、写者到来，则按到达顺序处理
:::

``` c {1-4,10,15}
wsem :互斥信号量，用于用于Writers和Readers 互斥
readcount 统计同时读数据的Readers个数
mrc 对变量readcount 进行互斥
wrsem 互斥信号量，确定Writer、Reader请求顺序
// 信号量定义
semaphore wsem=1,mrc=1,wrsem=1;
int readcount=0;
reader: 
    while(true){
        p(wrsem); // 🔒.确保顺序
        p(mrc);
        readcount++;
        if(readcount==1) p(wsem);
        v(mrc);
        v(wrsem);   //🔓
        读数据
        p(mrc);
        readcount--;
        if(readcount==0) v(wsem);
        v(mrc);
            
    }
writer:
    while(true){
        p(wrsem);
        p(wsem);
        写数据
        v(wsem);
        v(wrsem);
    }

```

**写者优先**
::: tip
- 当一个写者准备写数据时，不允许<warnBlock>新</warnBlock>的写者进入写数据
- 当一个新进程声明想写时，不允许新的读进程访问数据区
- <warnBlock>解决了写者饥饿问题，但是降低了系统的并发程度</warnBlock>
  
  <small>它限制了新的读请求的处理，在等待一个正在进行的或即将进行的写操作期间可能会浪费大量资源</small>
:::
``` c {1-2}
rsem 至少有一个写者在申请写数据时互斥新的读者进入读数据
writecount 用于控制rsem 信号量
mwc 对变量writecount 互斥算术操作
//信号量定义
semaphore wsem=1,rsem=1,wrsem=1,mec=1,mvc=1
int readcount=0,writecount=0

```
::: danger 注意
`读者和写者问题` :数据可多次读

`生产者与消费者问题` :数据消费后就没有了

:::



